

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#7108B2">
  <meta name="description" content="Perqin&#39;s GitHub pages powered by Hexo.io and hexo-theme-material.">
  <meta name="author" content="Perqin">
  <meta name="keywords" content="">
  
  <title>在Windows上编译Leaf Android - Perqin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/solarized-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"perqin.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#9575CD","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":"1279692316","leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Perqin's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="在Windows上编译Leaf Android">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-04 21:50" pubdate>
        2021年5月4日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      61
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">在Windows上编译Leaf Android</h1>
            
            <div class="markdown-body">
              <p><a target="_blank" rel="noopener" href="https://github.com/eycorsican/leaf">Leaf</a>是一款使用Rust编写的跨平台代理框架，作者同时也提供了Android上运行的demo工程。最近半个月，经过不懈努力，我总算也把Leaf在我的手机上跑起来了，这里记录下中间遇到的各种坑（当然，会省略大量瞎搜索、瞎看代码的过程）。</p>
<h2 id="在Windows上交叉编译Leaf"><a href="#在Windows上交叉编译Leaf" class="headerlink" title="在Windows上交叉编译Leaf"></a>在Windows上交叉编译Leaf</h2><h3 id="bindgen编译时libclang缺失：其一"><a href="#bindgen编译时libclang缺失：其一" class="headerlink" title="bindgen编译时libclang缺失：其一"></a>bindgen编译时libclang缺失：其一</h3><p>Leaf作者推荐在Linux机器上编译Leaf，而我平时用Windows笔记本多一些，因此尝试并最终摸索出了在Windows上编译的方法。</p>
<p>首先，安装Rust工具链、Android SDK和Android NDK，添加<code>aarch64-linux-android</code>和<code>x86_64-linux-android</code>target，这里不赘述。</p>
<p>安装完毕之后，参考作者提供的<code>build.sh</code>，我们首先需要设置交叉编译的target对应的linker和ar工具的路径。这些工具都来自于NDK，注意虽然作者给出的来自Mozilla的教程中提到这些工具需要使用NDK中的<code>make_standalone_toolchain.py</code>工具来生成，但2021年的我们可以安装r19或更高版本的NDK，这些版本的NDK中已经有了针对每个API预编译的工具链，以API 23为例，我需要指定以下环境变量：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$Env:CARGO_TARGET_AARCH64_LINUX_ANDROID_AR</span> = <span class="hljs-string">&#x27;C:\Users\Perqin\AppData\Local\Android\Sdk\ndk\21.1.6352462\toolchains\llvm\prebuilt\windows-x86_64\bin\aarch64-linux-android-ar.exe&#x27;</span><br><span class="hljs-variable">$Env:CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER</span> = <span class="hljs-string">&#x27;C:\Users\Perqin\AppData\Local\Android\Sdk\ndk\21.1.6352462\toolchains\llvm\prebuilt\windows-x86_64\bin\aarch64-linux-android23-clang.cmd&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>需要注意工具的后缀（exe和cmd），谷歌在Windows版本的NDK中同时放了Windows和Linux的clang可执行程序。</p>
<blockquote>
<p>关于API级别的选择，这里应该选择你的Android项目的minSdkVersion，也就是最低支持版本的NDK，这样才能保证不会链接到高版本Android上才有定义的函数和变量。</p>
</blockquote>
<p>接下来运行编译命令：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">cargo build <span class="hljs-params">--target</span> aarch64-linux-android <span class="hljs-params">--no-default-features</span> <span class="hljs-params">--features</span> <span class="hljs-string">&quot;leaf/default-ring&quot;</span> <span class="hljs-params">--release</span><br></code></pre></div></td></tr></table></figure>
<p>不出意外的话此时编译会失败，报找不到libclang的错误。</p>
<p>这是因为Leaf使用了<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust-bindgen">bindgen</a>来生成bindings，而bindgen依赖clang提供的libclang动态链接库来解析c/cpp文件里的内容。</p>
<p>在Linux中打开NDK的LLVM工具链，会发现libclang是存在的：</p>
<p><img src="image-20210504223012028.png" srcset="/img/loading.gif" lazyload></p>
<p>而Windows版本的NDK里居然没有：</p>
<p><img src="image-20210504223158768.png" srcset="/img/loading.gif" lazyload></p>
<p>我在NDK的仓库里提了<a target="_blank" rel="noopener" href="https://github.com/android/ndk/issues/1491">issue</a>，得到的答复是：Linux上的libclang是送你的，我们本来就不准备提供这些玩意儿。</p>
<p><strong>如果你只是需要顺利编译的话，不需要跟着我踩下面的坑，你可以直接跳过下面的配置部分，阅读《bindgen编译时libclang缺失：其二》章节。</strong></p>
<p>好在Clang本身就是支持交叉编译的，因此我们只需要自己安装一套就行了。我一开始安装的是Visual Studio里的版本，安装后将其lib路径指定到<code>LIBCLANG_PATH</code>中即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$Env:LIBCLANG_PATH</span> = <span class="hljs-string">&#x27;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\Llvm\x64\lib&#x27;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意选择x64目录下的。</p>
</blockquote>
<p>但是谷歌在NDK里带的Clang还有一定程度的魔改，其实主要是增加了Android相关target的支持，也就是默认指定了一些include路径，而VS中提供的Clang当然没有这些配置，因此我们需要将这些配置也加上。</p>
<p>我们可以先运行NDK中的clang，随便编译一个文件，带上<code>-v</code>参数看看它带了什么路径：</p>
<p><img src="image-20210504224300456.png" srcset="/img/loading.gif" lazyload></p>
<p>然后我们就可以通过<code>BINDGEN_EXTRA_CLANG_ARGS</code>这个环境变量将需要额外指定给Clang的参数带进去。在编译Leaf的时候实际上只用到了<code>&lt;android/log.h&gt;</code>，所以不需要那么多路径，我这里是这样指定的（其中<code>ndkLlvmRoot</code>变量的值是NDK中LLVM工具链的路径）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$Env:BINDGEN_EXTRA_CLANG_ARGS</span> = <span class="hljs-string">&quot;--target=aarch64-linux-android23 -isystem &#x27;<span class="hljs-variable">$ndkLlvmRoot</span>\sysroot\usr\include&#x27; -isystem &#x27;<span class="hljs-variable">$ndkLlvmRoot</span>\lib64\clang\11.0.5\include&#x27;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>到这里就可以在Windows上顺利编译出libleafandroid.so了。</p>
<h3 id="修复Leaf在Windows下不构建lwip"><a href="#修复Leaf在Windows下不构建lwip" class="headerlink" title="修复Leaf在Windows下不构建lwip"></a>修复Leaf在Windows下不构建lwip</h3><p>在编译成功拿到libleafandroid.so之后，我放进Android项目里跑起来，结果发现一运行就崩溃了，报找不到符号<code>ip_addr_any_type</code>。</p>
<p>在Leaf的代码中搜索之后，发现这个符号是在lwip项目的代码中声明的。</p>
<p>我先跑到<a target="_blank" rel="noopener" href="https://github.com/eycorsican/aleaf/actions/runs/747697441">Leaf的GitHub Actions</a>中拿到作者编译的libleafandroid.so，惊奇地发现这份so是可以运行的。</p>
<p>于是，我装上WSL2，在WSL2中配置好构建环境，又编译了一次，发现WSL中编译的so也是可以运行的。</p>
<p>在构建target产出目录中摸索的时候，我终于发现了其中的不同：在我的<code>target\aarch64-linux-android\release\build\leaf-f624836c6ef73483\out</code>目录中，只有一个<code>mobile_bindings.rs</code>文件，但根据Leaf的<a target="_blank" rel="noopener" href="https://github.com/eycorsican/leaf/blob/10e600d27db13d0aada6917c3df9ad4afec5cf40/leaf/build.rs"><code>build.rs</code></a>文件，这个目录中还需要产出liblwip.a等lwip库的编译产出物才对。</p>
<p>在这个过程中，我也稍微了解了一下Rust的构建流程（虽然我完全不会Rust来着）：</p>
<p><img src="rust-build.png" srcset="/img/loading.gif" lazyload></p>
<p>如图所示，某些Rust库会有一个build.rs文件，这个文件是用于构建这个库的，里面的代码会以开发者的<strong>本地机器</strong>为目标平台编译，并运行编译后的可执行文件来提前构建一些外部依赖。例如Leaf需要在编译它自身的Rust源码之前先编译好lwip等其他语言写的库，就需要在build.rs中进行编译。</p>
<p>而我遇到的文件就在于此，在旧的build.rs中使用了cfg选项来条件编译，作者应该是希望仅Android目标编译lwip：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(all(</span><br><span class="hljs-meta">    feature = <span class="hljs-meta-string">&quot;inbound-tun&quot;</span>,</span><br><span class="hljs-meta">    any(</span><br><span class="hljs-meta">        target_os = <span class="hljs-meta-string">&quot;ios&quot;</span>,</span><br><span class="hljs-meta">        target_os = <span class="hljs-meta-string">&quot;android&quot;</span>,</span><br><span class="hljs-meta">        target_os = <span class="hljs-meta-string">&quot;macos&quot;</span>,</span><br><span class="hljs-meta">        target_os = <span class="hljs-meta-string">&quot;linux&quot;</span></span><br><span class="hljs-meta">    )</span><br><span class="hljs-meta">))]</span><br>&#123;<br>    <span class="hljs-keyword">let</span> os = env::var(<span class="hljs-string">&quot;CARGO_CFG_TARGET_OS&quot;</span>).unwrap();<br>    <span class="hljs-keyword">if</span> os == <span class="hljs-string">&quot;ios&quot;</span> || os == <span class="hljs-string">&quot;android&quot;</span> || os == <span class="hljs-string">&quot;linux&quot;</span> || os == <span class="hljs-string">&quot;macos&quot;</span> &#123;<br>        compile_lwip();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> env::var(<span class="hljs-string">&quot;BINDINGS_GEN&quot;</span>).is_ok()<br>        &amp;&amp; (os == <span class="hljs-string">&quot;ios&quot;</span> || os == <span class="hljs-string">&quot;android&quot;</span> || os == <span class="hljs-string">&quot;linux&quot;</span> || os == <span class="hljs-string">&quot;macos&quot;</span>)<br>    &#123;<br>        generate_lwip_bindings();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>然而如前所述，build.rs是在我的Windows上运行的，并不是目标平台的代码，因此在其中使用cfg的target_os来条件编译就会出错了。在Linux平台上能成功的原因嘛，则是上面的判断条件歪打正着地匹配上了Linux……</p>
<p>于是我给作者提了一个PR（关联<a target="_blank" rel="noopener" href="https://github.com/eycorsican/leaf/issues/169">issue</a>），解决了这个问题之后再编译得到的so终于可以正常运行了。</p>
<h2 id="在Gradle项目中集成Rust构建"><a href="#在Gradle项目中集成Rust构建" class="headerlink" title="在Gradle项目中集成Rust构建"></a>在Gradle项目中集成Rust构建</h2><h3 id="接入rust-android-gradle插件"><a href="#接入rust-android-gradle插件" class="headerlink" title="接入rust-android-gradle插件"></a>接入rust-android-gradle插件</h3><p>到此为止，我们只是手动完成了so的编译，但这意味着每次我们将代码修改之后都需要手动编译一次so，然后再启动Android编译。自然而然地，我希望能够把Cargo构建任务放进Gradle项目中。而我们也已经有了这样的插件：<a target="_blank" rel="noopener" href="https://github.com/mozilla/rust-android-gradle">rust-android-gradle</a>。</p>
<p>然而不幸的是，这个插件已经停止更新很久了，无法支持我项目中使用的AGP 4.1.3。</p>
<p>幸运的是，作者收到了<a target="_blank" rel="noopener" href="https://github.com/mozilla/rust-android-gradle/issues/53">群众的呼声</a>，又回坑了，并且已经在他的fork上完成了一版修改。于是，我拉取了它<a target="_blank" rel="noopener" href="https://github.com/ncalexan/rust-android-gradle/tree/citest">修改后的插件代码</a>，在IDEA中打开并构建出jar，放进了我的项目中，配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy"><span class="hljs-comment">// build.gradle</span><br>buildscript &#123;<br>    dependencies &#123;<br>        classpath files(<span class="hljs-string">&#x27;./gradle-plugins/org.mozilla.rust-android-gradle-plugin-0.8.6.jar&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// app/build.gradle</span><br>plugins &#123;<br>    <span class="hljs-comment">// ...</span><br>    id <span class="hljs-string">&#x27;org.mozilla.rust-android-gradle.rust-android&#x27;</span><br>&#125;<br><br>android &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Rust build configuration!</span><br>cargo &#123;<br>    module  = <span class="hljs-string">&quot;../leaf-android&quot;</span><br>    libname = <span class="hljs-string">&quot;leafandroid&quot;</span><br>    targets = [<span class="hljs-string">&quot;arm64&quot;</span>, <span class="hljs-string">&quot;x86_64&quot;</span>]<br>    prebuiltToolchains = <span class="hljs-literal">true</span><br>    profile = <span class="hljs-string">&#x27;release&#x27;</span><br>    features &#123;<br>        noDefaultBut(<span class="hljs-string">&quot;leaf/default-ring&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Build leaf during building app</span><br>tasks.whenTaskAdded &#123; task -&gt;<br>    <span class="hljs-keyword">if</span> ((task.name == <span class="hljs-string">&#x27;javaPreCompileDebug&#x27;</span> || task.name == <span class="hljs-string">&#x27;javaPreCompileRelease&#x27;</span>)) &#123;<br>        task.dependsOn <span class="hljs-string">&#x27;cargoBuild&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>各参数的使用可以直接查阅插件文档，同时需要注意安装正确版本的NDK，因为rust-android-gradle插件会读取你所使用的<a target="_blank" rel="noopener" href="https://developer.android.com/studio/projects/install-ndk#default-ndk-per-agp">AGP版本对应的默认NDK版本</a>，如果你没有强制指定的话，就需要按照这个版本对应关系下载好对应的NDK。</p>
<p>这回可以顺利编译了，我启动了Gradle任务，并开始翻阅插件文档，因为前面提到的libclang问题在这里肯定也得再解决一下才行。</p>
<p>可谁知使用插件之后，编译顺利完成了？！</p>
<h3 id="bindgen编译时libclang缺失：其二"><a href="#bindgen编译时libclang缺失：其二" class="headerlink" title="bindgen编译时libclang缺失：其二"></a>bindgen编译时libclang缺失：其二</h3><p>如前所述，Windows上构建的时候是找不到libclang.dll的，为什么编译成功了呢？</p>
<h4 id="Q1：bindgen怎么找到了libclang-dll"><a href="#Q1：bindgen怎么找到了libclang-dll" class="headerlink" title="Q1：bindgen怎么找到了libclang.dll"></a>Q1：bindgen怎么找到了libclang.dll</h4><p>bindgen依赖<a target="_blank" rel="noopener" href="https://github.com/KyleMayes/clang-sys">clang-sys</a>这个库来查找和链接libclang动态库，回顾一下前面的Rust构建流程，leaf在编译Rust源码之前，会运行leaf-build-script.exe，这里面会调用bindgen，因此会把bindgen编译成libbindgen.dll，而bindgen运行时又依赖clang-sys，因此clang-sys源码中的<code>build/*.rs</code>也会被编译为libclang-sys.dll后在我的Windows机器上运行。</p>
<p>捋清楚前面的逻辑之后，我们看clang-sys中<a target="_blank" rel="noopener" href="https://github.com/KyleMayes/clang-sys/blob/master/build/common.rs">查找libclang的代码</a>（省略了部分逻辑）：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">/// Returns the paths to and the filenames of the `libclang` static or dynamic</span><br><span class="hljs-comment">/// libraries matching the supplied filename patterns.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">search_libclang_directories</span></span>(files: &amp;[<span class="hljs-built_in">String</span>], variable: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Vec</span>&lt;(PathBuf, <span class="hljs-built_in">String</span>)&gt; &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// Search the `bin` and `lib` directories in directory provided by</span><br>    <span class="hljs-comment">// `llvm-config --prefix`.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(output) = run_llvm_config(&amp;[<span class="hljs-string">&quot;--prefix&quot;</span>]) &#123;<br>        <span class="hljs-keyword">let</span> directory = Path::new(output.lines().next().unwrap()).to_path_buf();<br>        found.extend(search_directories(&amp;directory.join(<span class="hljs-string">&quot;bin&quot;</span>), files));<br>        found.extend(search_directories(&amp;directory.join(<span class="hljs-string">&quot;lib&quot;</span>), files));<br>        found.extend(search_directories(&amp;directory.join(<span class="hljs-string">&quot;lib64&quot;</span>), files));<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// Determine the `libclang` directory patterns.</span><br>    <span class="hljs-keyword">let</span> directories = <span class="hljs-keyword">if</span> <span class="hljs-built_in">cfg!</span>(any(target_os = <span class="hljs-string">&quot;freebsd&quot;</span>, target_os = <span class="hljs-string">&quot;linux&quot;</span>)) &#123;<br>        DIRECTORIES_LINUX<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cfg!</span>(target_os = <span class="hljs-string">&quot;macos&quot;</span>) &#123;<br>        DIRECTORIES_MACOS<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">cfg!</span>(target_os = <span class="hljs-string">&quot;windows&quot;</span>) &#123;<br>        DIRECTORIES_WINDOWS<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        &amp;[]<br>    &#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上述代码有两个重要的逻辑：运行llvm-config和检查target_os。</p>
<p>前面提到过Leaf在Linux上是可以顺利编译的，查看作者提供的<a target="_blank" rel="noopener" href="https://github.com/eycorsican/aleaf/blob/master/app/src/main/rust/leaf-android/build.sh">编译脚本</a>可以发现：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">export PATH=&quot;$NDK_HOME/toolchains/llvm/prebuilt/$HOST_OS-$HOST_ARCH/bin/&quot;:$PATH<br></code></pre></div></td></tr></table></figure>
<p>作者将NDK中的LLVM工具链放进了环境变量里。这使clang-sys查找过程中可以顺利运行<code>llvm-config --prefix</code>命令，打印出NDK中LLVM的安装路径，并顺着这个路径找到谷歌白给的libclang.so加以使用，这就是Linux可以正常编译的原因。</p>
<p>然而这对Windows来说没有意义，因为Windows上NDK里的LLVM缺胳膊少腿。于是我们需要后面的逻辑。如前所述，这里的<code>target_os</code>自然是<code>windows</code>，因此我们会在<code>DIRECTORIES_WINDOWS</code>里找：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">/// `libclang` directory patterns for Windows.</span><br><span class="hljs-keyword">const</span> DIRECTORIES_WINDOWS: &amp;[&amp;<span class="hljs-built_in">str</span>] = &amp;[<br>    <span class="hljs-string">&quot;C:\\LLVM\\lib&quot;</span>,<br>    <span class="hljs-string">&quot;C:\\Program Files*\\LLVM\\lib&quot;</span>,<br>    <span class="hljs-string">&quot;C:\\MSYS*\\MinGW*\\lib&quot;</span>,<br>    <span class="hljs-comment">// LLVM + Clang can be installed as a component of Visual Studio.</span><br>    <span class="hljs-comment">// https://github.com/KyleMayes/clang-sys/issues/121</span><br>    <span class="hljs-string">&quot;C:\\Program Files*\\Microsoft Visual Studio\\*\\BuildTools\\VC\\Tools\\Llvm\\**\\bin&quot;</span>,<br>];<br></code></pre></div></td></tr></table></figure>
<p>接下来就是本篇最大乌龙……</p>
<p>事情是这样子的：</p>
<ol>
<li>我安装了NDK，编译时发现找不到libclang，这是因为NDK中缺了libclang；</li>
<li>我在VS中安装了Clang，编译时还是找不到libclang，这是因为上面的路径和我VS中LLVM的路径对不上（原因不明，但这不重要）；</li>
<li>我手动把VS中Clang的路径指定给<code>LIBCLANG_PATH</code>环境变量，终于可以找到了，此时我处于好奇，还随手去llvm.org下载了原味LLVM 12，但是<strong>被我安装到非默认位置</strong>了，导致clang-sys按照上面的常量找没找到；</li>
<li>我最终通过环境变量解决了编译问题，并发现我所使用的NDK r22里的LLVM是11.0.5的，于是去下载了一个原味LLVM 11.1.0，并<strong>安装到了默认位置</strong>，想以此验证这个LLVM版本也是跑得通的；</li>
<li>我开始配置rust-android-gradle插件，插件编译的时候直接取到了我的原味LLVM 11.1.0。</li>
</ol>
<p>好家伙，当初为了这个问题我还特地拉AOSP里的NDK源码尝试编译，折腾大半个月白折腾了……</p>
<h4 id="Q2：isystem参数如何被指定的？"><a href="#Q2：isystem参数如何被指定的？" class="headerlink" title="Q2：isystem参数如何被指定的？"></a>Q2：<code>isystem</code>参数如何被指定的？</h4><p>如前所说，指定<code>LIBCLANG_PATH</code>环境变量还不够，还需要指定一些额外的Clang参数，否则Windows版本的LLVM是不知道去NDK目录里找头文件的。但是为什么rust-gradle-plugin里编译的时候成功了呢？</p>
<p>首先，<a target="_blank" rel="noopener" href="https://github.com/mozilla/rust-android-gradle/blob/master/plugin/src/main/kotlin/com/nishtahir/CargoBuildTask.kt#L207">插件</a>中为我们指定了CLANG_PATH环境变量，指向了我们NDK中的CLANG可执行程序：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-comment">// CargoBuildTask.kt</span><br><span class="hljs-comment">// Set CLANG_PATH in the environment, so that bindgen (or anything</span><br><span class="hljs-comment">// else using clang-sys in a build.rs) works properly, and doesn&#x27;t</span><br><span class="hljs-comment">// use host headers and such.</span><br><span class="hljs-keyword">val</span> shouldConfigure = cargoExtension.getFlagProperty(<br>    <span class="hljs-string">&quot;rust.autoConfigureClangSys&quot;</span>,<br>    <span class="hljs-string">&quot;RUST_ANDROID_GRADLE_AUTO_CONFIGURE_CLANG_SYS&quot;</span>,<br>    <span class="hljs-comment">// By default, only do this for non-desktop platforms. If we&#x27;re</span><br>    <span class="hljs-comment">// building for desktop, things should work out of the box.</span><br>    toolchain.type != ToolchainType.DESKTOP<br>)<br><span class="hljs-keyword">if</span> (shouldConfigure) &#123;<br>    environment(<span class="hljs-string">&quot;CLANG_PATH&quot;</span>, cc)<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>接下来，bindgen<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust-bindgen/blob/master/src/lib.rs#L2193">有一段逻辑</a>会尝试解析需要include的路径：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">detect_include_paths</span></span>(options: &amp;<span class="hljs-keyword">mut</span> BindgenOptions) &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">let</span> clang = <span class="hljs-keyword">match</span> clang_sys::support::Clang::find(<br>        <span class="hljs-literal">None</span>,<br>        &amp;clang_args_for_clang_sys,<br>    ) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span>,<br>        <span class="hljs-literal">Some</span>(clang) =&gt; clang,<br>    &#125;;<br><br>    debug!(<span class="hljs-string">&quot;Found clang: &#123;:?&#125;&quot;</span>, clang);<br><br>    <span class="hljs-comment">// Whether we are working with C or C++ inputs.</span><br>    <span class="hljs-keyword">let</span> is_cpp = args_are_cpp(&amp;options.clang_args) ||<br>    options<br>    .input_header<br>    .as_ref()<br>    .map_or(<span class="hljs-literal">false</span>, |i| file_is_cpp(&amp;i));<br><br>    <span class="hljs-keyword">let</span> search_paths = <span class="hljs-keyword">if</span> is_cpp &#123;<br>        clang.cpp_search_paths<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        clang.c_search_paths<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(search_paths) = search_paths &#123;<br>        <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> search_paths.into_iter() &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Ok</span>(path) = path.into_os_string().into_string() &#123;<br>                options.clang_args.push(<span class="hljs-string">&quot;-isystem&quot;</span>.to_owned());<br>                options.clang_args.push(path);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>detect_include_paths(&amp;<span class="hljs-keyword">mut</span> options);<br></code></pre></div></td></tr></table></figure>
<p>如上所示，bindgen会查找clang可执行程序，并运行它，得到c、cpp的头文件搜索路径，并追加到参数里。而这个<code>clang_sys::support::Clang::find</code>里的实现，正是使用到了<code>CLANG_PATH</code>这个插件注入的环境变量，取到了NDK里的clang可执行程序，解析到了需要的头文件目录！</p>
<p>因为以上的原因，我们不再需要手动指定环境变量，插件就能为我们完成构建了。</p>
<h2 id="解决stopLeaf崩溃"><a href="#解决stopLeaf崩溃" class="headerlink" title="解决stopLeaf崩溃"></a>解决stopLeaf崩溃</h2><p>在完成编译顺利运行之后，我又遇到了新的问题：调用<code>stopLeaf</code>之后，应用会崩溃，而日志中就只有两行：</p>
<figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">--------- beginning of crash<br><span class="hljs-number">2021-05-04</span> <span class="hljs-number">17</span>:<span class="hljs-number">34:35.688</span> <span class="hljs-number">29209-29279</span>/com.perqin.bamboo <span class="hljs-keyword">A</span>/libc: fdsan: attempted to close file descriptor <span class="hljs-number">111</span>, expected to be unowned, actually owned by ParcelFileDescriptor <span class="hljs-number">0</span>xec55a51<br><span class="hljs-number">2021-05-04</span> <span class="hljs-number">17</span>:<span class="hljs-number">34:35.689</span> <span class="hljs-number">29209-29279</span>/com.perqin.bamboo <span class="hljs-keyword">A</span>/libc: Fatal signal <span class="hljs-number">6</span> (SIGABRT), code -<span class="hljs-number">1</span> (SI_QUEUE) in tid <span class="hljs-number">29279</span> (Thread-<span class="hljs-number">4</span>), pid <span class="hljs-number">29209</span> (m.perqin.bamboo)<br></code></pre></div></td></tr></table></figure>
<p>这个111文件描述符的确是我从Java层传递给Leaf的，但是Leaf在哪里关闭了它呢？我摸索了一天才找到答案。</p>
<p>从Java层传入的配置文件，被解析之后放入了这个结构体中，而这个文件描述符也被放到了fd成员里：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// leaf:src/config/internal/config.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TunInboundSettings</span></span> &#123;<br>    <span class="hljs-comment">// message fields</span><br>    <span class="hljs-keyword">pub</span> fd: <span class="hljs-built_in">i32</span>,<br>    <span class="hljs-keyword">pub</span> auto: <span class="hljs-built_in">bool</span>,<br>    <span class="hljs-keyword">pub</span> name: ::std::string::<span class="hljs-built_in">String</span>,<br>    <span class="hljs-keyword">pub</span> address: ::std::string::<span class="hljs-built_in">String</span>,<br>    <span class="hljs-keyword">pub</span> gateway: ::std::string::<span class="hljs-built_in">String</span>,<br>    <span class="hljs-keyword">pub</span> netmask: ::std::string::<span class="hljs-built_in">String</span>,<br>    <span class="hljs-keyword">pub</span> mtu: <span class="hljs-built_in">i32</span>,<br>    <span class="hljs-keyword">pub</span> fake_dns_exclude: ::protobuf::RepeatedField&lt;::std::string::<span class="hljs-built_in">String</span>&gt;,<br>    <span class="hljs-keyword">pub</span> fake_dns_include: ::protobuf::RepeatedField&lt;::std::string::<span class="hljs-built_in">String</span>&gt;,<br>    <span class="hljs-comment">// special fields</span><br>    <span class="hljs-keyword">pub</span> unknown_fields: ::protobuf::UnknownFields,<br>    <span class="hljs-keyword">pub</span> cached_size: ::protobuf::CachedSize,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>而后被放入了Configuration对象中，用于构造AsyncDevice：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// leaf:src/proxy/tun/inbound.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(<br>    inbound: Inbound,<br>    dispatcher: Arc&lt;Dispatcher&gt;,<br>    nat_manager: Arc&lt;NatManager&gt;,<br>) -&gt; <span class="hljs-built_in">Result</span>&lt;Runner&gt; &#123;<br>    <span class="hljs-keyword">let</span> settings = TunInboundSettings::parse_from_bytes(&amp;inbound.settings)?;<br><br>    <span class="hljs-keyword">let</span> cfg = <span class="hljs-keyword">if</span> settings.fd &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cfg = tun::Configuration::default();<br>        cfg.raw_fd(settings.fd);<br>        cfg<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> settings.auto &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">let</span> tun = tun::create_as_async(&amp;cfg).unwrap();<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在构造中，这个fd也被通过<code>Fd::new</code>包装到了<code>platform::posix::Fd</code>对象里：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// rust-tun:src/platform/android/device.rs</span><br><span class="hljs-keyword">use</span> crate::platform::posix::&#123;<span class="hljs-keyword">self</span>, Fd&#125;;<br><br><span class="hljs-keyword">impl</span> Device &#123;<br>    <span class="hljs-comment">/// Create a new `Device` for the given `Configuration`.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(config: &amp;Configuration) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">match</span> config.raw_fd &#123;<br>            <span class="hljs-literal">Some</span>(raw_fd) =&gt; raw_fd,<br>            _ =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::InvalidConfig),<br>        &#125;;<br>        <span class="hljs-keyword">let</span> device = &#123;<br>            <span class="hljs-keyword">let</span> tun = Fd::new(fd).map_err(|_| io::Error::last_os_error())?;<br><br>            Device &#123;<br>                queue: Queue &#123; tun: tun &#125;,<br>            &#125;<br>        &#125;;<br>        <span class="hljs-literal">Ok</span>(device)<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>而Fd这个对象实现了Drop这个trait，并且会调用libc关闭这个文件描述符：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// rust-tun:src/platform/posix/fd.rs</span><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Fd &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> &gt;= <span class="hljs-number">0</span> &#123;<br>                libc::close(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>而在leaf代码中，通过<code>select_all</code>并行执行了多个Future，当我们调用stopLeaf的时候，其中用于监听shutdown信号的Future就是完成，并导致<code>select_all</code>完成：</p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">start</span></span>(rt_id: RuntimeId, opts: StartOptions) -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt; &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> tasks: <span class="hljs-built_in">Vec</span>&lt;Runner&gt; = <span class="hljs-built_in">Vec</span>::new();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> runners = <span class="hljs-built_in">Vec</span>::new();<br>    <span class="hljs-comment">// ...</span><br>    tasks.push(<span class="hljs-built_in">Box</span>::pin(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        futures::future::join_all(runners).<span class="hljs-keyword">await</span>;<br>    &#125;));<br><br>    <span class="hljs-comment">// Monitor shutdown signal.</span><br>    tasks.push(<span class="hljs-built_in">Box</span>::pin(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        <span class="hljs-keyword">let</span> _ = shutdown_rx.recv().<span class="hljs-keyword">await</span>;<br>    &#125;));<br><br>    RUNTIME_MANAGER<br>        .lock()<br>        .map_err(|_| Error::RuntimeManager)?<br>        .insert(rt_id, runtime_manager);<br><br>    rt.block_on(futures::future::select_all(tasks));<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>于是可以推测，在<code>select_all</code>完成之后，除了shutdown这个Future完成了，其他Future（包括正在持有fd的Future，在runners中）以及关联的变量就都离开了作用域，Rust判断他们可以被Drop了，于是就drop了。这也是为什么我打日志后发现在<code>rt.block_on(futures::future::select_all(tasks));</code>这行发生了crash。</p>
<p>这个文件描述符在Java层是通过<code>VpnService.Builder.establish</code>方法返回的ParcelFileDescriptor对象中获得的。我们会看到他的注释中明确说明需要app主动关闭这个文件描述符：</p>
<p><img src="index.png" srcset="/img/loading.gif" lazyload></p>
<p>而要让native来负责关闭的话，就需要调用<code>detachFd</code>，在Java层主动释放对文件描述符的拥有权。调用这个方法之后，stopLeaf果然不会奔溃了。</p>
<p>稍微深究一下ParcelFileDescriptor的实现就会发现，在构造对象的时候我们就声明了拥有权（<code>IoUtils.setFdOwner(mFd, this)</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParcelFileDescriptor</span><span class="hljs-params">(FileDescriptor fd, FileDescriptor commChannel)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;FileDescriptor must not be null&quot;</span>);<br>    &#125;<br>    mWrapped = <span class="hljs-keyword">null</span>;<br>    mFd = fd;<br>    IoUtils.setFdOwner(mFd, <span class="hljs-keyword">this</span>);<br><br>    mCommFd = commChannel;<br>    <span class="hljs-keyword">if</span> (mCommFd != <span class="hljs-keyword">null</span>) &#123;<br>        IoUtils.setFdOwner(mCommFd, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    mGuard.open(<span class="hljs-string">&quot;close&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>而常规情况下，在Java层关闭时调用的<code>close</code>会关闭这个fd（<code>IoUtils.closeQuietly(mFd)</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeWithStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status, String msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mClosed) <span class="hljs-keyword">return</span>;<br>    mClosed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (mGuard != <span class="hljs-keyword">null</span>) &#123;<br>        mGuard.close();<br>    &#125;<br>    <span class="hljs-comment">// Status MUST be sent before closing actual descriptor</span><br>    writeCommStatusAndClose(status, msg);<br>    IoUtils.closeQuietly(mFd);<br>    releaseResources();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但如果我们调用<code>detachFd</code>呢？</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">detachFd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mWrapped != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> mWrapped.detachFd();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mClosed) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already closed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> fd = IoUtils.acquireRawFd(mFd);<br>        writeCommStatusAndClose(Status.DETACHED, <span class="hljs-keyword">null</span>);<br>        mClosed = <span class="hljs-keyword">true</span>;<br>        mGuard.close();<br>        releaseResources();<br>        <span class="hljs-keyword">return</span> fd;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>可见我们仅仅是把这个ParcelFileDescriptor关闭了，但并没有真正关闭fd。</p>
<p>我们再去cs.android.com搜索<code>IoUtils.setFdOwner</code>的实现：</p>
<p><img src="image-20210505004002025.png" srcset="/img/loading.gif" lazyload></p>
<p>在注释里我们看到了……哟，这不是fdsan吗？<del>几天不见，这么拉了</del></p>
<p>可见fdsan这个玩意儿就是负责维护文件描述符的拥有权管理，如果一个文件描述符被一个Java对象指定了拥有，随后又在native层被关闭，fdsan就能马上检测到这里可能存在误关闭。</p>
<p>谷歌搜索一下fdsan：</p>
<p><img src="image-20210505004251692.png" srcset="/img/loading.gif" lazyload></p>
<p>可知fdsan是Android 10才被引入的，而Android 11上发生了行为变更，在10的时候检测到误关闭时只会打印警告，但是11上会直接崩溃。</p>
<p>而我手上的索尼Xperia 5 ii<del>（非异形屏带3.5mm耳机孔你值得拥有）</del>正好前阵子升级到了Android 11，因此遇到了这个问题，而作者的设备大概还不是Android 11，所以没有复现。</p>
<h2 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h2><p>作为995的社畜，难得五一连休尽情地折腾了一把side project，真是太爽了，感觉没什么用的知识又增加了不少www</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/21/from-flutter-build-failure-to-pr/">
                        <span class="hidden-mobile">从Flutter编译错误到给Flutter贡献代码</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://perqin.github.io/2021/05/04/build-leaf-android-on-windows/';
          this.page.identifier = '/2021/05/04/build-leaf-android-on-windows/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'perqin-github-io' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
    <!-- cnzz Analytics Icon -->
    <span id="cnzz_stat_icon_1279692316" style="display: none"></span>
  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1279692316&show=pic"
            type="text/javascript"></script>
  




  
<script src="/js/live2dcubismcore.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/dylanNew/live2d@fd9fd40/webgl/Live2D/lib/live2d.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.10/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.3.1/dist/index.js"></script>
<script src="https://cdn.jsdelivr.net/gh/perqin/live2d-widget@v5+f9bc441/autoload.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
